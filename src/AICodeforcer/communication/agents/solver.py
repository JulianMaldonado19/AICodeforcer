"""Communication problem solver agent."""

import os
import re
from datetime import datetime
from pathlib import Path
from typing import Callable, TextIO

from dotenv import load_dotenv
from google import genai
from google.genai import types

from AICodeforcer.api_logger import APILogger
from AICodeforcer.communication.agents.preprocessor import CommunicationPreprocessor
from AICodeforcer.communication.tools.stress_test import communication_stress_test
from AICodeforcer.standard.agents.cpp_translator import CppTranslator
from AICodeforcer.standard.tools import run_python_code

load_dotenv()
_max_output_tokens: int = int(os.getenv("GEMINI_MAX_OUTPUT_TOKENS", "65536"))
_api_max_retries: int = int(os.getenv("API_REQUEST_MAX_RETRIES", "30"))

SYSTEM_PROMPT = """<role>
You are a top-tier ICPC / CCPC competitive programming algorithm assistant specialized in communication problems.
Your sole objective is: to reliably and reproducibly solve communication problems and output AC-ready final code.

You can call tools to experiment, verify, and stress test your ideas and implementations.
Core Philosophy: Code experimentation first. Whenever a key idea/assumption/encoding strategy emerges, write code to verify first, then draw conclusions.
</role>

<communication-problem-overview>
Communication problems have two phases:
- Phase 1 (Alice): Receives original input, outputs intermediate data
- Phase 2 (Bob): Receives transformed input (from middleware), outputs final answer

Your solver code must handle BOTH phases in a single file:
- First line of input is "first" or "second" to indicate the phase
- If "first": act as Alice
- If "second": act as Bob
</communication-problem-overview>

<available-tools>
  <tool name="run_python_code">
    <signature>run_python_code(code, test_input)</signature>
    <description>Execute code and return output (for small-scale experiments, simulation, and verifying non-interactive logic)</description>
  </tool>
  <tool name="stress_test">
    <signature>stress_test(solution_code)</signature>
    <description>Communication stress test verification</description>
    <note>Middleware, verifier, and generator are pre-generated by the system, you only need to provide solution_code</note>
  </tool>
</available-tools>

<core-principles title="Must Not Be Violated">
  <principle>Correctness > Verifiability > Complexity Feasibility > Engineering Implementation</principle>
  <principle name="Experiment-Driven">Any unverified inference is an "assumption" and must be:
    <item>Logically proven, or</item>
    <item>Supported by Python small-scale experiments</item>
  </principle>
  <principle>Encoding/decoding schemes must be explicitly verified with code, not just assumed</principle>
  <principle>If you are deducing more than 1-2 key steps, immediately write code to experiment</principle>
  <principle>Greedy / hashing / compression / parity / packing strategies: No experimental verification = Not trustworthy</principle>
</core-principles>

<problem-solving-process title="Mandatory - Must Be Demonstrated">
  <step name="Problem Restatement and Phase Responsibilities">
    <task>Restate the problem in your own words</task>
    <task>Split responsibilities into Alice input, middleware transform, Bob output</task>
    <task>Clarify I/O format for both phases</task>
  </step>

  <step name="Information and Encoding Design">
    <task>Identify the minimum information Bob needs to compute the final answer</task>
    <task>Design an encoding scheme that Alice can send and Bob can decode</task>
    <task>Check size constraints on what Alice can output (if any)</task>
    <task>Mark key assumptions that need verification</task>
  </step>

  <step name="Python Experimentation and Simulation Verification" requirement="must-execute">
    <instruction>You must proactively use run_python_code to complete at least one of:</instruction>
    <task>Simulate small cases to verify encode/decode correctness</task>
    <task>Check for collisions or ambiguity in the encoding</task>
    <task>Find counterexamples and fix the strategy</task>
    <requirement>Write code to verify whenever you have an idea, never just "self-consistent" in your head.</requirement>
  </step>

  <step name="Final Strategy Determination">
    <task>Finalize algorithm for Alice and Bob</task>
    <task>Provide complexity and message size analysis</task>
    <task>Ensure the protocol is deterministic and decodable</task>
  </step>

  <step name="Implementation Details">
    <task>Handle both phases in one file based on the first line</task>
    <task>Read input line-by-line; do not use sys.stdin.read</task>
    <task>Stop reading once sufficient input is parsed if possible</task>
    <task>Follow output format exactly, with no extra text</task>
  </step>

  <step name="Communication Stress Test Verification" requirement="must-execute-before-submission">
    <instruction>Before outputting final code, you must call stress_test(solution_code).</instruction>
    <note>If failed, read logs, fix strategy and implementation, stress test again.</note>
  </step>

  <step name="Final Submission Code">
    <task>Output complete, directly submittable Python code</task>
    <task>No debug output</task>
    <task>Use fast I/O where appropriate</task>
  </step>
</problem-solving-process>

<code-standards priority="critical">
  <standard name="Self-Contained and Standard Library Only">
    <rule>Code must be complete and runnable as-is in a single file</rule>
    <rule>Explicitly import all required modules</rule>
    <rule>Use Python standard library only; no third-party libraries</rule>
  </standard>

  <standard name="Input Handling">
    <rule>Do not use sys.stdin.read()</rule>
    <rule>Read input line-by-line (e.g., sys.stdin.readline or iterating sys.stdin)</rule>
    <rule>If the amount of data is known by the problem, stop reading once parsed</rule>
  </standard>

  <standard name="Output Format and Noise Control">
    <rule>Never output debug information, logs, or explanations</rule>
    <rule>Output must be exactly consistent with the problem requirements</rule>
    <rule>ALL_TESTS_PASSED is a dialogue marker only; never print or include it in solution code</rule>
  </standard>

  <standard name="Phase Separation">
    <rule>Clearly separate Alice and Bob logic with dedicated functions</rule>
    <rule>The first input line selects phase: "first" or "second"</rule>
  </standard>
</code-standards>

<solver-template>
import sys

def solve_alice(original_input_lines):
    # Process original input
    # Output intermediate data for middleware
    pass

def solve_bob(transformed_input_lines):
    # Process transformed input from middleware
    # Output final answer
    pass

def main():
    first_line = sys.stdin.readline()
    if not first_line:
        return
    phase = first_line.strip()

    data_lines = []
    for line in sys.stdin:
        data_lines.append(line.rstrip("\\n"))

    if phase == "first":
        solve_alice(data_lines)
    elif phase == "second":
        solve_bob(data_lines)
    else:
        return

if __name__ == "__main__":
    main()
</solver-template>

<completion-flag>
  <strict-requirements>
    <requirement>Must call stress_test for verification</requirement>
    <requirement>Must see "AC" returned to consider stress test passed</requirement>
    <requirement>Only after all above steps are completed and passed can you output "ALL_TESTS_PASSED"</requirement>
    <requirement>ALL_TESTS_PASSED is a dialogue marker only and must never appear in the solution code</requirement>
  </strict-requirements>

  <forbidden-behaviors>
    <forbidden>Never claim tests passed without calling tools</forbidden>
    <forbidden>Never skip stress test verification</forbidden>
    <forbidden>Never claim stress test passed without seeing "AC"</forbidden>
    <forbidden>Never print "ALL_TESTS_PASSED" inside the code</forbidden>
  </forbidden-behaviors>
</completion-flag>
"""


def _stress_test_wrapper(
    solution_code: str,
    generator_code: str,
    middleware_code: str,
    verifier_code: str,
) -> str:
    """Wrapper for communication stress test."""
    return communication_stress_test(
        solver_code=solution_code,
        generator_code=generator_code,
        middleware_code=middleware_code,
        verifier_code=verifier_code,
    )


TOOL_DECLARATIONS = [
    types.Tool(function_declarations=[
        types.FunctionDeclaration(
            name="run_python_code",
            description="执行 Python 代码并返回结果。",
            parameters=types.Schema(
                type=types.Type.OBJECT,
                properties={
                    "code": types.Schema(
                        type=types.Type.STRING,
                        description="要执行的 Python 代码",
                    ),
                    "test_input": types.Schema(
                        type=types.Type.STRING,
                        description="测试输入",
                    ),
                },
                required=["code", "test_input"],
            ),
        ),
        types.FunctionDeclaration(
            name="stress_test",
            description="通讯题对拍验证。你只需提供 solution_code。",
            parameters=types.Schema(
                type=types.Type.OBJECT,
                properties={
                    "solution_code": types.Schema(
                        type=types.Type.STRING,
                        description="求解器代码（处理 Alice 和 Bob 两个阶段）",
                    ),
                },
                required=["solution_code"],
            ),
        ),
    ])
]


class CommunicationSolver:
    """Gemini-powered communication problem solver."""

    def __init__(
        self,
        api_key: str | None = None,
        base_url: str | None = None,
        model: str | None = None,
        log_dir: str | None = None,
    ):
        self.api_key = api_key or os.environ.get("GEMINI_API_KEY")
        if not self.api_key:
            raise ValueError("API key required.")

        self.base_url = base_url or os.environ.get("GEMINI_BASE_URL")
        self.model = model or os.environ.get("GEMINI_MODEL", "gemini-2.5-flash")

        if self.base_url:
            self.client = genai.Client(
                api_key=self.api_key,
                http_options=types.HttpOptions(base_url=self.base_url),
            )
        else:
            self.client = genai.Client(api_key=self.api_key)

        self._contents: list[types.Content] = []
        self._config: types.GenerateContentConfig | None = None
        self._last_code: str | None = None

        self._log_dir = Path(log_dir) if log_dir else Path("logs")
        self._log_file: TextIO | None = None
        self._log_path: Path | None = None
        self._api_logger = APILogger(self._log_dir)

        # Preprocessor for generating middleware/verifier/generator
        self._preprocessor = CommunicationPreprocessor(
            api_key=self.api_key,
            base_url=self.base_url,
            model=self.model,
        )
        self._generator_code: str | None = None
        self._middleware_code: str | None = None
        self._verifier_code: str | None = None
        self._cpp_translator = CppTranslator(
            api_key=self.api_key,
            base_url=self.base_url,
            model=self.model,
        )
        self._cpp_code: str | None = None

    def _init_log(self, problem_text: str) -> None:
        """初始化日志文件。"""
        session_dir = APILogger.create_session(self._log_dir)
        self._log_path = session_dir / "communication_solve.log"
        self._log_file = open(self._log_path, "w", encoding="utf-8")
        self._api_logger.init(prefix="communication_solve", model=self.model)

        self._log(f"{'='*80}")
        self._log("AICodeforcer 通讯题求解日志")
        self._log(f"时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        self._log(f"模型: {self.model}")
        self._log(f"{'='*80}\n")
        self._log(problem_text)
        self._log(f"{'='*80}\n")

    def _log(self, message: str) -> None:
        if self._log_file:
            self._log_file.write(message + "\n")
            self._log_file.flush()

    def _close_log(self) -> None:
        if self._log_file:
            self._log_file.close()
            self._log_file = None
            print(f"\n[日志] 已保存到: {self._log_path}")
        self._api_logger.close()

    def _translate_to_cpp(self, python_code: str | None) -> str | None:
        """Translate Python code to C++."""
        if not python_code:
            return None
        cpp_code = self._cpp_translator.translate(python_code)
        if cpp_code:
            self._cpp_code = cpp_code
            self._log("\n--- C++ 翻译结果 ---")
            self._log(cpp_code)
        else:
            self._log("[翻译] C++ 翻译失败")
        return cpp_code

    def solve(
        self,
        problem_text: str,
        max_attempts: int = 20,
        on_attempt: Callable[[int, str], None] | None = None,
    ) -> tuple[str | None, str | None, bool]:
        """Solve a communication problem.

        Returns:
            (python_code, cpp_code, success) tuple
        """
        self._init_log(problem_text)
        try:
            return self._solve_impl(problem_text, max_attempts, on_attempt)
        finally:
            self._close_log()

    def _solve_impl(
        self,
        problem_text: str,
        max_attempts: int,
        on_attempt: Callable[[int, str], None] | None,
    ) -> tuple[str | None, str | None, bool]:
        """实际的求解逻辑。"""
        # 预处理：生成 middleware/verifier/generator
        print("\n[预处理] 生成通讯题组件...")
        self._log("[预处理] 开始生成 middleware/verifier/generator")

        preprocess_result = self._preprocessor.generate(problem_text)
        if not preprocess_result:
            print("[预处理] 生成失败")
            self._log("[预处理] 生成失败")
            return None, None, False

        self._generator_code, self._middleware_code, self._verifier_code = preprocess_result
        self._log(f"[预处理] 生成器: {len(self._generator_code)} 字符")
        self._log(f"[预处理] 中间件: {len(self._middleware_code)} 字符")
        self._log(f"[预处理] 验证器: {len(self._verifier_code)} 字符")

        # 配置
        config = types.GenerateContentConfig(
            system_instruction=SYSTEM_PROMPT,
            tools=TOOL_DECLARATIONS,
            automatic_function_calling=types.AutomaticFunctionCallingConfig(disable=True),
            temperature=1.0,
            max_output_tokens=_max_output_tokens,
            thinking_config=types.ThinkingConfig(thinking_level="high"),
        )

        contents: list[types.Content] = []
        initial_prompt = f"""请解决以下通讯题：

{problem_text}

你的代码需要处理两个阶段：
- 输入第一行是 "first" 时，作为 Alice 处理
- 输入第一行是 "second" 时，作为 Bob 处理

请使用 stress_test 工具验证你的解法。"""

        contents.append(types.Content(
            role="user",
            parts=[types.Part.from_text(text=initial_prompt)],
        ))

        last_code: str | None = None
        stress_test_passed = False
        verified_code: str | None = None

        for turn in range(max_attempts):
            response = self._call_api(contents, config)
            if not response:
                break

            candidate = response.candidates[0] if response.candidates else None
            if not candidate or not candidate.content:
                print(f"[Turn {turn + 1}] 无响应内容")
                break

            response_content = candidate.content
            contents.append(response_content)

            response_text = ""
            function_calls = []
            for part in response_content.parts:
                if part.text:
                    response_text += part.text
                if part.function_call:
                    function_calls.append(part.function_call)

            print(f"\n{'='*60}")
            print(f"Turn {turn + 1}")
            print("=" * 60)
            if response_text:
                preview = response_text[:1000] if len(response_text) > 1000 else response_text
                print(preview)

            code = self._extract_code(response_text)
            if code:
                last_code = code
                if on_attempt:
                    on_attempt(turn + 1, code)

            # 检查完成标志
            if "ALL_TESTS_PASSED" in response_text and not function_calls:
                if stress_test_passed and verified_code:
                    self._contents = contents
                    self._config = config
                    self._last_code = verified_code
                    cpp_code = self._translate_to_cpp(verified_code)
                    return verified_code, cpp_code, True
                else:
                    contents.append(types.Content(
                        role="user",
                        parts=[types.Part.from_text(
                            text="请调用 stress_test 工具验证。"
                        )],
                    ))
                    continue

            # 处理工具调用
            if function_calls:
                print(f"\n[工具调用] 共 {len(function_calls)} 个")
                function_responses = []

                for fc in function_calls:
                    func_name = fc.name
                    func_args = dict(fc.args) if fc.args else {}

                    if func_name == "stress_test":
                        solution_code = func_args.get("solution_code", "")
                        result = _stress_test_wrapper(
                            solution_code=solution_code,
                            generator_code=self._generator_code,
                            middleware_code=self._middleware_code,
                            verifier_code=self._verifier_code,
                        )
                        if result == "AC":
                            stress_test_passed = True
                            verified_code = solution_code
                            print("    [对拍] 通过!")
                        else:
                            stress_test_passed = False
                            verified_code = None
                            print(f"    [对拍] 失败: {result[:200]}...")

                    elif func_name == "run_python_code":
                        result = run_python_code(
                            code=func_args.get("code", ""),
                            test_input=func_args.get("test_input", ""),
                        )
                        print(f"    结果: {result[:200]}...")
                    else:
                        result = f"Unknown function: {func_name}"

                    function_responses.append(types.Part.from_function_response(
                        name=func_name,
                        response={"result": result},
                    ))

                contents.append(types.Content(
                    role="user",
                    parts=function_responses,
                ))

                if stress_test_passed and verified_code:
                    self._contents = contents
                    self._config = config
                    self._last_code = verified_code
                    cpp_code = self._translate_to_cpp(verified_code)
                    return verified_code, cpp_code, True
            else:
                if turn < max_attempts - 1:
                    contents.append(types.Content(
                        role="user",
                        parts=[types.Part.from_text(text="请继续。")],
                    ))

        self._contents = contents
        self._config = config
        self._last_code = last_code
        return last_code, None, False

    def _call_api(self, contents, config):
        """Call API with retry logic."""
        import time
        for retry in range(_api_max_retries):
            try:
                self._api_logger.log_request(contents, config)
                response = self.client.models.generate_content(
                    model=self.model,
                    contents=contents,
                    config=config,
                )
                self._api_logger.log_response(response)
                return response
            except Exception as e:
                self._api_logger.log_response(None, error=str(e))
                print(f"请求失败 (重试 {retry + 1}/{_api_max_retries}): {e}")
                if retry == _api_max_retries - 1:
                    return None
                time.sleep(5)
        return None

    def _extract_code(self, text: str) -> str | None:
        """Extract Python code from response text."""
        patterns = [
            r"```python\n(.*?)```",
            r"```py\n(.*?)```",
            r"```\n(.*?)```",
        ]
        for pattern in patterns:
            matches = re.findall(pattern, text, re.DOTALL)
            if matches:
                return matches[-1].strip()
        return None
